---
layout: post
title: Linux应用开发-gcc（一）
comments: true
category: Ubuntu
tags: [gcc, ubuntu, application]
---

## gcc选项

### -o filename

指定输出文件的名字。当你正在编译一个目标文件时，你一般不会使用这个选项，因为默认设置下用filename o代替filename.c。

然而，如果你正在构造一个可执行文件，默认情况下是构造一个名为a.out的可执行文件。如果你希望把输出文件放到另外的目录

中的话，那么他也是很有用的。

### -c

对在命令行中指定的源代码文件只编译不链接，为每个源文件构建一个目标文件。当使用make的时候，每个对象文件通常都调用

一次gcc，因而如果有错误发生，那么很容易知道是哪个文件失败了。然而，当你手动输入命令时，在一次gcc的调用中指定很多

文件通常是很有用的。在多数情况下，在命令行中指定很多输入文件容易出错，最好只指定一个，否则会引起gcc的混淆

### -Dfoo

在命令行中定义一个预处理程序的宏。

### -Idir

将dir目录加入搜寻头文件的目录路径

### -Ldir

将dir目录加入搜寻库的目录路径。在没有特别指明的情况下，gcc将优先于静态库使用共享库

### -lfoo

链接libfoo库。除非已经被指明，gcc链接将优先于静态库（libfoo.a）链接共享库（libfoo.so）。链接器在所有被列

出来的库当中顺序搜索函数，知道找到每个函数。

### -static

只链接静态库。

### -g，-ggdb

包括调试信息。-g选项指定gcc在编译和链接时报汉标准的调试信息。-ggdb选项指示gcc包含大量的，只有gdb调试器才

能理解的信息。如果你的硬盘空间有限，期望使用一个gdb之外的调试器，或者期望损失一些函数性能而换得链接速度时

可以使用-g。如果你需要在调试时获得所有帮助，那么使用-ggdb，这样gcc会把更多的信息传递个gdb。

与绝大多数的编译器不同的是，gcc可以在优化过的代码中包含调试信息。然而，通过使用调试工具来追踪优化过得代码

可能是一种挑战，代码路径可能会出现跳转，从而完全错过你所期望的执行的代码段。gcc还可以帮助你更好地理解代码，

以及编译器是如何对代码的执行进行优化的。

### -0，-0n

指示gcc优化你的代码。默认情况，gcc会做一些优化，指定一个数字来描述gcc优化的等级。最通常的优化等级是2；对于

标准版本的gcc，3是最高的优先级。除非你希望有较高的运行速度，编译得快一些，否则如果你期望使用一个调试器输出

文件，或者你在优化器当中找到一个程序缺陷，我们建议你在编译的时候使用-02或-03；-03可能增加你应用程序的大小，

如果你对程序的大小很在意，那么我们建议你这两种方式都尝试一下。如果内存大小或者硬盘空间是你的应用程序的瓶颈的

话，你也可以考虑使用-0s，该选项用来优化代码大小，而不是速度。

gcc只有在使用最小优化（-0）的时候才会出现内联函数。

### -ansi

支持所有标准ANSI（X3.159-1989）或技术上等同于ISO（ISO/IEC 9899：1990）的C语言程序（通常被缩写为C89或偶尔被缩

写为C90）。注意这不会强迫你完全遵守ANSI/ISO的规则。选项-ansi避开了gcc的那些与ANSI/ISO标准冲突的扩展。（因为许

多的这些扩展也被其他的C编译器所支持，这个在实践当中很少成为问题。）它同时也定义了_STARICT_ANSI_属性宏，它的头

文件使用提供一个遵从ANSI/ISO标准的环境。

### -pedantic

给出被ANSI/ISO的C语言标准所要求的所有警告和错误。这并不是强迫你绝对服从ANSI/ISO标准。

### -Wall

打开所有的gcc通用的并且有用的警告信息。它不会打开在某写特殊情况瞎猜有用的选项。改选项提供了一个与Lint语法检查

器类似的，针对源代码进行语法检查的细节级别。gcc允许你打开或关闭每个单独的警告信息。

##  头文件

在浏览Linux的头文件时，你可能会发现一些超出了非ANSI/ISO兼容的C语言数据结构。有一些是非常值得去理解的。

### long long

Long long类型表示一种至少和long类型一样大的存储单元。在Intel的i86和其他的32位平台上，long是32位字宽，

而long long是64位字宽。在64位的平台上，指针和long long都是64位字宽，而long可能是32位也可能是64位，在

“C99”（ISO/IEC 9899：1999）语法中支持的long long类型很早就被gcc所提供。

### 内联函数

某些Linux头文件（特别是针对特定系统的头文件）普遍使用内联函数。它们和宏一样快（没有函数调用的额外开销），

但是提供正常函数的类型检测。调用内联函数的代码在编译时至少要进行最小限度的优化（即使用-0选项）。

### 其他可选择的扩展关键字

在gcc中，每个扩展关键字（指ANSI/ISO标准中没有涉及到的关键字）有两个版本：关键字本身和关键字前后加两个

下划线。当在标准模式下使用编译器时（通常是因为使用了-ansi参数），正常的扩展关键字不会被识别出来。所以，

举例来说，关键字attribute在头文件中写作__attribute__。

### 属性

扩展关键字attribute（属性）用来告诉gcc更多ANSI/ISO兼容C代码之外的函数、变量或者声明类型。例如，aligned

属性更准确地告诉gcc如何分配一个变量或者类型；packed属性指定不是用填料；noreturn属性指明一个函数没有返

回值，从而允许gcc进行更好的优化并且避免多余的警告。

函数属性声明放在函数声明中，例如

```

void die_die_die(int, char *) __attribute__ ((__noretrun__));

```

属性声明放在后括号和结尾的分号之间，在一个attribute关键字后面跟包含了属性内容的双括号。如果有很多属性，

使用逗号分隔列表。

```

int printm(char *, ...)

    __attribute__ ((const, format (printf, 1, 2)))

    ;

```

上面的例子说明printm不会检查任何数值，包括他的参数，并且对于生成代码（const）没有任何副作用，而gcc应

该像它检查printf（）的参数一样检查传给Printm的参数。Printm的第一个参数是格式字符串，第二个参数是第一

个替换参数（即格式参数）。

##  参考资料

《Linux应用程序开发》
